#!/bin/bash
# Renames PS4 PKG files based on param.sfo information and predefined patterns.
# Requires script "sfo" (https://github.com/hippie68/sfo) in $PATH.

# How the filename should look like:
pattern='$title [$category] [$title_id]$releasegroup.pkg'
# Possible variables: title, category, releasegroup
# Plus original SFO strings: app_ver, content_id, title_id, version

customize_title() {
  title=${title//[®™]/}
  title=${title//–/-}
  title=${title//’/\'}
  title=${title//＆/&}
  # Remove irregular whitespace (may look like a regular space here, but isn't)
  title=${title// / }
}

customize() {
  customize_title
  # How different categories should look like:
  category_game="BASE GAME"
  category_patch="UPDATE v${app_ver#0}"
  category_dlc="DLC"
  # Add brackets when releasegroup not empty:
  if [[ $releasegroup != "" ]]; then
    releasegroup=" [$releasegroup]"
  fi
  # Uncomment this if you want exFAT placeholders for : and & to disappear:
  #title=${title//:/}; title=${title//  / }
  #if [[ $title == *[a-z]* ]]; then
  #  title=${title// & / and }
  #else
  #  title=${title// & / AND }
  #fi
}

#######################
# Script starts below

show_usage() {
  echo "Usage: ${0##*/} [-fhor] [file/directory ...]" >&2
}

show_help() {
  show_usage 2>&1
  echo
  echo "  Automatically renames PKG files based on customizable patterns."
  echo "  Customization takes place inside the script file."
  echo "  If no files or directories are specified, the current directory will be used."
  echo
  echo "  Options:"
  echo "    -f  Force prompt when file name matches pattern"
  echo "    -h  Display this help info"
  echo "    -o  Default to online search"
  echo "    -r  Traverse directories recursively"
  exit
}

find_option="-maxdepth 1"

# Parse command line options
while [[ $1 == "-"?* ]]; do
  for ((i=1;i<${#1};i++)); do
    case ${1:$i:1} in
      f) force_prompt=true ;;
      h) show_help ;;
      r) find_option= ;;
      o) search_ps_store=true ;;
      *) show_usage; exit 1 ;;
    esac
  done
  shift
done

[[ $1 == "" ]] && set -- '.' # Use current directory if no arguments given

cleanup() {
  echo "Script aborted."
  exit
}

trap '{ echo; cleanup; }' SIGINT

# Prints a message and reads a keystroke until input is valid
# $1: Message, $2: Allowed characters
read_userinput() {
  local char
  while read -e -t 0.01; do true; done # Clear buffer
  while [[ ${char,,} != [$2] ]]; do
    read -p "$1" -n 1 char
    while read -e -t 0.01; do true; done
    echo
  done
  userinput=${char,,}
}

# https://www.ntfs.com/exfat-filename-dentry.htm
convert_to_exfat_filename() {
  echo "${1//[&:\\|\/\"<>*]/_}"
}

# Optionally searches the PS Store for better titles (option -s)
online_search() {
  case $content_id in
    UP*) url="https://store.playstation.com/en-us/product/$content_id" ;;
    EP*) url="https://store.playstation.com/en-gb/product/$content_id" ;;
    JP*) url="https://store.playstation.com/ja-jp/product/$content_id" ;;
    *) return ;;
  esac
  online_search_result=$(curl --silent "$url" \
    | grep -Po -m1 '"@type":"Product","name":"\K[^"]*(?=")')
  if [[ $online_search_result == "" ]]; then
    echo "PS Store title search failed." >&2
  else
    title=$online_search_result
  fi
}

# Accepts a PKG file and renames it
pkgrename() {
  local app_ver category content_id title title_id version releasegroup \
    newfilename online_search_result
  echo "${1##*/}"
  while IFS= read -r line; do
    case "${line%%=*}" in
      APP_VER) app_ver=${line#*=} ;; # Patch version
      CATEGORY) category=${line#*=} ;; # ac: DLC, gd: Game, gp: Patch
      CONTENT_ID) content_id=${line#*=} ;; # https://www.psdevwiki.com/ps4/Content_ID
      TITLE) title=${line#*=} ;; # Game/Patch/DLC name
      TITLE_ID) title_id=${line#*=} ;; # CUSAXXXXX
      VERSION) version=${line#*=} ;; # Master version
    esac
  done < <(sfo "$1")
  # Check file name for release groups
  case "${1,,}" in
    *[^a-z]blz[^a-z]*|*[^a-z]blaze[^a-z]*) releasegroup="BlaZe" ;;
    *[^a-z]caf[^a-z]*) releasegroup="CAF" ;;
    *[^a-z]darkmoon[^a-z]*) releasegroup="DarKmooN" ;;
    *[^a-z]duplex[^a-z]*) releasegroup="DUPLEX" ;;
    *[^a-z]gcmr[^a-z]*) releasegroup="GCMR" ;;
    *[^a-z]hoodlum[^a-z]*) releasegroup="HOODLUM" ;;
    *[^a-z]hr[^a-z]*) releasegroup="HR" ;;
    *[^a-z]jrp[^a-z]*) releasegroup="JRP" ;;
    *[^a-z]kotf[^a-z]*) releasegroup="KOTF" ;;
    *[^a-z]lfc[^a-z]*|*[^a-z]lightforce[^a-z]*) releasegroup="LiGHTFORCE" ;;
    *[^a-z]marvtm[^a-z]*) releasegroup="MarvTM" ;;
    *[^a-z]moemoe[^a-z]*) releasegroup="MOEMOE" ;;
    *[^a-z]playable[^a-z]*) releasegroup="Playable" ;;
    *[^a-z]prelude[^a-z]*) releasegroup="PRELUDE" ;;
    *[^a-z]respawn[^a-z]*) releasegroup="RESPAWN" ;;
    *[^a-z]tcd[^a-z]*) releasegroup="TCD" ;;
    *[^a-z]unlimited[^a-z]*) releasegroup="UNLiMiTED" ;;
  esac
  [[ $search_ps_store == true ]] && online_search # Option -o
  customize
  case "$category" in
    ac) category="$category_dlc" ;;
    gd) category="$category_game" ;;
    gp) category="$category_patch" ;;
  esac
  title_backup=$title # For [R]eset
  while true; do
    newfilename=$(convert_to_exfat_filename "$(eval echo $pattern)")
    echo "$newfilename"
    if [[ $newfilename == "${1##*/}" && $force_prompt != true ]]; then
      echo "Nothing to do."
      break
    elif [[ $rename_all == true ]]; then
      mv "$1" "$(dirname "$1")/$newfilename"
      break
    else
      read_userinput "Rename? [Y]es [N]o [A]ll [E]dit [M]ix [O]nline [R]eset [C]hars [S]FO [Q]uit: " ynaemorcsq
      case "$userinput" in
        y) mv "$1" "$(dirname "$1")/$newfilename"; break ;;
        n) break ;;
        a) mv "$1" "$(dirname "$1")/$newfilename"; rename_all=true; break ;;
        e) read -i "$title" -e title ;;
        m) title=${title,,}
           array=($title)
           title=${array[@]~}
           ;;
        o) online_search; customize_title ;;
        r) title=$title_backup ;;
        c) special_chars=$(echo -n "$newfilename" | cat -A);
           if [[ $special_chars != "$newfilename" ]]; then
             echo "$special_chars <-- Special characters found"
           else
             echo "No special characters found."
           fi
           ;;
        s) echo; sfo "$1"; echo; ;;
        q) cleanup ;;
      esac
    fi
  done
  echo
}

while [[ $1 != "" ]]; do
  if [[ -d "$1" ]]; then
    while IFS= read -r -d $'\0' -u 3 pkg; do # File descriptor 3 because: nested reads
      pkgrename "$pkg"
    done 3< <(find "$1" $find_option -iname '*.pkg' -type f -print0 | sort -z)
  elif [[ -f "$1" && ${1,,} == *.pkg ]]; then
    pkgrename "$1"
  fi
  shift
done

#!/bin/bash
# Renames PS4 PKG files based on param.sfo information and predefined patterns.
# Requires script "sfo" (https://github.com/hippie68/sfo) in $PATH.

#########################
# Customization section:

# How the filename should look like:
pattern='$title [$category] [$title_id] [$releasegroup].pkg'
# Possible variables: title, category, firmware, releasegroup
# Plus original SFO strings: app_ver, content_id, title_id, version

# Replacement for characters that would be invalid on an exFAT file system:
exfat_placeholder=_

# Do title customization here:
# e.g. title=${title//SEARCH/REPLACE}
customize_title() {
  title=${title//[®™]/}
  title=${title//–/-}
  title=${title//’/\'}
  title=${title//＆/&}
  # Replace irregular whitespace with regular one:
  title=${title// / }
  # Uncomment these lines if you want placeholders for : and & to disappear:
  #title=${title//:/}; title=${title//  / }
  #if [[ $title == *[a-z]* ]]; then
  #  title=${title// & / and }
  #else
  #  title=${title// & / AND }
  #fi
}

# Do all other file name customization here:
customize() {
  # How different categories should look like:
  category_game="Game"
  category_patch="Update v${app_ver#0}"
  category_dlc="DLC"
  # Optional: characters to remove should a variable be empty:
  outer_shell="[]"
}

#######################
# Script starts below:

show_usage() {
  echo "Usage: ${0##*/} [-fhor] [file/directory ...]" >&2
}

show_help() {
  show_usage 2>&1
  echo "
  Automatically renames PKG files based on customizable patterns.
  Customization takes place inside the script file.
  If no files or directories are specified, the current directory will be used.

  Options:
    -f  Force prompt when file name matches pattern
    -h  Display this help info
    -o  Default to online search
    -r  Traverse directories recursively"
  exit
}

find_option="-maxdepth 1"

# Parse command line options
while [[ $1 == "-"?* ]]; do
  for ((i=1;i<${#1};i++)); do
    case ${1:$i:1} in
      f) force_prompt=true ;;
      h) show_help ;;
      o) search_ps_store=true ;;
      r) find_option= ;;
      *) show_usage; exit 1 ;;
    esac
  done
  shift
done

[[ $1 == "" ]] && set -- '.' # Use current directory if no arguments given

cleanup() {
  echo "Script aborted."
  exit
}

trap '{ echo; cleanup; }' SIGINT

# Prints a message and reads a keystroke until input is valid
# $1: Message, $2: Allowed characters
read_userinput() {
  local char
  while read -e -t 0.01; do true; done # Clear buffer
  while [[ ${char,,} != [$2] ]]; do
    read -p "$1" -n 1 char
    while read -e -t 0.01; do true; done
    echo
  done
  userinput=${char,,}
}

# Optionally searches the PS Store for better titles (option -s)
online_search() {
  case $content_id in
    UP*) url="https://store.playstation.com/en-us/product/$content_id" ;;
    EP*) url="https://store.playstation.com/en-gb/product/$content_id" ;;
    JP*) url="https://store.playstation.com/ja-jp/product/$content_id" ;;
    *) return ;;
  esac
  online_search_result=$(curl --silent "$url" \
    | grep -Po -m1 '"@type":"Product","name":"\K[^"]*(?=")')
  if [[ $online_search_result == "" ]]; then
    echo "Online search failed." >&2
  else
    title=$online_search_result
    echo "Online search successful."
  fi
}

# Renames a file on case-insensitive filesystems like exFAT
rename_file() {
  if [[ -f "$2" ]]; then
   if [[ -f "$1.pkgrename" ]]; then
     echo "The old temporary file \"$1.pkgrename\" prevents renaming." >&2
     echo "Please fix this and then try again." >&2
   else
     mv "$1" "$1.pkgrename" && mv "$1.pkgrename" "$2"
   fi
  else
    mv "$1" "$2"
  fi
}

# Accepts a PKG file and renames it
pkgrename() {
  local app_ver category content_id firmware newfilename online_search_result \
    pubtoolinfo releasegroup title title_id version
  echo "${1##*/}"

  # Run external "sfo" script to get param.sfo variables
  while IFS= read -r line; do
    case "${line%%=*}" in
      APP_VER) app_ver=${line#*=} ;; # Patch version
      CATEGORY) category=${line#*=} ;; # ac: DLC, gd: Game, gp: Patch
      CONTENT_ID) content_id=${line#*=} ;; # https://www.psdevwiki.com/ps4/Content_ID
      PUBTOOLINFO) pubtoolinfo=${line#*=} ;;
      TITLE) title=${line#*=} ;; # Game/Patch/DLC name
      TITLE_ID) title_id=${line#*=} ;; # CUSAXXXXX
      VERSION) version=${line#*=} ;; # Master version
    esac
  done < <(sfo "$1")

  # Create "firmware" variable (stays empty if PKG is DLC)
  if [[ $category == +(gd|gp) ]]; then
    firmware=${pubtoolinfo#*sdk_ver=}
    firmware=${firmware%%,*}
    firmware=${firmware:0:2}.${firmware:2:2}
    firmware=${firmware#0}
  fi

  # Check file name for release groups
  case ${1,,} in
    *[^a-z]bigbluebox[^a-z]*) releasegroup="BigBlueBox" ;;
    *[^a-z]blz[^a-z]*|*[^a-z]blaze[^a-z]*) releasegroup="BlaZe" ;;
    *[^a-z]caf[^a-z]*) releasegroup="CAF" ;;
    *[^a-z]darkmoon[^a-z]*) releasegroup="DarKmooN" ;;
    *[^a-z]duplex[^a-z]*) releasegroup="DUPLEX" ;;
    *[^a-z]gcmr[^a-z]*) releasegroup="GCMR" ;;
    *[^a-z]hoodlum[^a-z]*) releasegroup="HOODLUM" ;;
    *[^a-z]hr[^a-z]*) releasegroup="HR" ;;
    *[^a-z]jrp[^a-z]*) releasegroup="JRP" ;;
    *[^a-z]kotf[^a-z]*) releasegroup="KOTF" ;;
    *[^a-z]levelup[^a-z]*) releasegroup="LevelUp" ;;
    *[^a-z]lfc[^a-z]*|*[^a-z]lightforce[^a-z]*) releasegroup="LiGHTFORCE" ;;
    *[^a-z]marvtm[^a-z]*) releasegroup="MarvTM" ;;
    *[^a-z]moemoe[^a-z]*) releasegroup="MOEMOE" ;;
    *[^a-z]playable[^a-z]*) releasegroup="Playable" ;;
    *[^a-z]prelude[^a-z]*) releasegroup="PRELUDE" ;;
    *[^a-z]protocol[^a-z]*) releasegroup="PROTOCOL" ;;
    *[^a-z]respawn[^a-z]*) releasegroup="RESPAWN" ;;
    *[^a-z]sharphd[^a-z]*) releasegroup="SharpHD" ;;
    *[^a-z]tcd[^a-z]*) releasegroup="TCD" ;;
    *[^a-z]unlimited[^a-z]*) releasegroup="UNLiMiTED" ;;
    *[^a-z]walmart[^a-z]*) releasegroup="WaLMaRT" ;;
    *[^a-z]waysted[^a-z]*) releasegroup="WaYsTeD" ;;
    # Other releases
    *[^a-z]arczi[^a-z]*) releasegroup="By Arczi" ;;
    *[^a-z]opoisso893[^a-z]*) releasegroup="By OPOISSO893" ;;
    *[^a-z]cyb1k[^a-z]*) releasegroup="By CyB1K" ;;
  esac

  # This line is option "-o", must be run before title customization
  [[ $search_ps_store == true ]] && online_search

  # Apply user's customization
  customize_title
  title_backup=$title # Backup for possible use of [R]eset
  customize
  case "$category" in
    ac) category="$category_dlc" ;;
    gd) category="$category_game" ;;
    gp) category="$category_patch" ;;
    *) category="Unknown category" ;;
  esac

  # Interactive loop
  while true; do
    # Apply user's pattern
    newfilename=$(eval echo $pattern)

    # Remove outer shell characters and whitespace caused by empty variables
    newfilename=${newfilename//$outer_shell/}
    newfilename=${newfilename//  / }
    newfilename=${newfilename/ ./.}

    # Encforce exFAT compatibility
    # (https://www.ntfs.com/exfat-filename-dentry.htm)
    newfilename=${newfilename//[&:\\|\/\"<>*]/$exfat_placeholder}

    echo "$newfilename"
    if [[ $newfilename == "${1##*/}" && $force_prompt != true ]]; then
      echo "Nothing to do."
      break
    elif [[ $rename_all == true ]]; then
      rename_file "$1" "$(dirname "$1")/$newfilename"
      break
    else
      read_userinput "Rename? [Y]es [N]o [A]ll [E]dit [M]ix [O]nline [R]eset [C]hars [S]FO [Q]uit: " ynaemorcsq
      case "$userinput" in
        y) rename_file "$1" "$(dirname "$1")/$newfilename"; break ;;
        n) break ;;
        a) rename_file "$1" "$(dirname "$1")/$newfilename"; rename_all=true; break ;;
        e) echo "Enter new title:"; read -i "$title" -e title ;;
        m)
          title=${title,,}
          array=($title)
          title=${array[@]~} # Uppercase for first letter of every word
          echo "Converted title to mixed-case style."
          ;;
        o) online_search; customize_title ;;
        r) title=$title_backup; echo "All changes reset." ;;
        c)
          special_chars=$(echo -n "$newfilename" | cat -A);
          if [[ $special_chars != "$newfilename" ]]; then
            echo "Special characters found:"
            echo "$special_chars"
          else
            echo "No special characters found."
          fi
          ;;
        s) echo; sfo "$1"; echo ;;
        q) cleanup ;;
      esac
    fi
  done
  echo
}

# File loop
while [[ $1 != "" ]]; do
  if [[ -d "$1" ]]; then
    # File descriptor 3 because of nested reads (function "read_userinput")
    while IFS= read -r -d $'\0' -u 3 pkg; do
      pkgrename "$pkg"
    done 3< <(find "$1" $find_option -iname '*.pkg' -type f -print0 | sort -z)
  elif [[ -f "$1" && ${1,,} == *.pkg ]]; then
    pkgrename "$1"
  fi
  shift
done
